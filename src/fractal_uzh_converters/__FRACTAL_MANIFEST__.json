{
  "manifest_version": "2",
  "task_list": [
    {
      "name": "Convert Olympus ScanR Plate to OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Olympus",
        "ScanR",
        "Plate converter"
      ],
      "docs_info": "### Purpose\n\n- Convert images acquired with an Olympus ScanR microscope to an OME-Zarr Plate.\n\n### Outputs\n\n- An OME-Zarr Plate.\n\n### Limitations\n\n- This task has been tested on a limited set of acquisitions. It may not work on all Olympus ScanR acquisitions.\n- Make sure to set the correct `Layout` for your plate. The well ID mapping depends on it \u2014 using the wrong layout will assign images to incorrect wells.\n\n### Expected inputs\n\nThe following directory structure is expected:\n\n```text\nmy_acquisition/\n\u2514\u2500\u2500 data/\n    \u251c\u2500\u2500 metadata.ome.xml     # OME-XML metadata file (required)\n    \u251c\u2500\u2500 image_001.tiff\n    \u251c\u2500\u2500 image_002.tiff\n    \u2514\u2500\u2500 ...\n```\n\n`Path` can point to either the base directory (`my_acquisition/`) or directly to the `data` subdirectory (`my_acquisition/data/`).\n",
      "type": "converter_compound",
      "executable_non_parallel": "olympus_scanr/convert_scanr_init_task.py",
      "executable_parallel": "common/image_in_plate_compute_task.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "AcquisitionOptions": {
            "description": "Acquisition options for conversion.",
            "properties": {
              "channels": {
                "description": "List of channel information.",
                "items": {
                  "$ref": "#/$defs/ChannelInfo"
                },
                "title": "Channels",
                "type": "array"
              },
              "pixel_info": {
                "$ref": "#/$defs/PixelSizeModel",
                "description": "Pixel size information.",
                "title": "Pixel Size Information"
              },
              "condition_table_path": {
                "description": "Optional path to a condition table CSV file.",
                "title": "Condition Table Path",
                "type": "string"
              },
              "axes": {
                "description": "Axes to use for the image data, e.g. \"czyx\".",
                "title": "Axes",
                "type": "string"
              },
              "data_type": {
                "$ref": "#/$defs/DataTypeEnum",
                "description": "Data type of the image data.",
                "title": "Data Type"
              },
              "stage_corrections": {
                "$ref": "#/$defs/StageCorrections",
                "default": {
                  "flip_x": false,
                  "flip_y": false,
                  "swap_xy": false
                },
                "description": "Stage orientation corrections.",
                "title": "Stage Corrections"
              },
              "filters": {
                "default": [],
                "description": "List of filters to apply.",
                "items": {
                  "discriminator": {
                    "mapping": {
                      "Path Regex Exclude Filter": "#/$defs/RegexExcludeFilter",
                      "Path Regex Include Filter": "#/$defs/RegexIncludeFilter",
                      "Well Filter": "#/$defs/WellFilter"
                    },
                    "propertyName": "name"
                  },
                  "oneOf": [
                    {
                      "$ref": "#/$defs/RegexExcludeFilter"
                    },
                    {
                      "$ref": "#/$defs/RegexIncludeFilter"
                    },
                    {
                      "$ref": "#/$defs/WellFilter"
                    }
                  ]
                },
                "title": "Filters",
                "type": "array"
              }
            },
            "title": "AcquisitionOptions",
            "type": "object"
          },
          "AlignmentCorrections": {
            "additionalProperties": false,
            "description": "Alignment correction for stage positions.",
            "properties": {
              "align_xy": {
                "default": false,
                "description": "Whether to align the positions in the XY plane by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align XY",
                "type": "boolean"
              },
              "align_z": {
                "default": false,
                "description": "Whether to align the positions in the Z axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align Z",
                "type": "boolean"
              },
              "align_t": {
                "default": false,
                "description": "Whether to align the positions in the T axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align T",
                "type": "boolean"
              }
            },
            "title": "AlignmentCorrections",
            "type": "object"
          },
          "BackendType": {
            "enum": [
              "anndata",
              "json",
              "csv",
              "parquet"
            ],
            "title": "BackendType",
            "type": "string",
            "description": "Missing description for BackendType."
          },
          "ChannelInfo": {
            "description": "Channel information.",
            "properties": {
              "channel_label": {
                "description": "Label of the channel.",
                "title": "Channel Label",
                "type": "string"
              },
              "wavelength_id": {
                "description": "The wavelength ID of the channel.\nThis field can be used in some tasks as alternative to channel_label,\ne.g. for multiplexed acquisitions it can be used for applying illumination\ncorrection based on wavelength ID instead of channel name.",
                "title": "Wavelength Id",
                "type": "string"
              },
              "colors": {
                "$ref": "#/$defs/DefaultColors",
                "default": "Blue (0000FF)",
                "description": "The color associated with the channel, e.g. for visualization purposes.",
                "title": "Colors"
              }
            },
            "required": [
              "channel_label"
            ],
            "title": "ChannelInfo",
            "type": "object"
          },
          "ConverterOptions": {
            "additionalProperties": false,
            "description": "Options for the OME-Zarr conversion process.",
            "properties": {
              "tiling_mode": {
                "$ref": "#/$defs/TilingMode",
                "default": "Auto",
                "description": "Tiling mode to use during conversion.\n- Auto: Automatically determine if Snap to Grid is possible,\notherwise use Snap to Corners.\n- Snap to Grid: Tile images to fit a regular grid. This is\nonly possible if image positions align to a grid (potentially with overlap).\n- Snap to Corners: Tile images to fit a grid defined by the corner\npositions.\n- Inplace: Write tiles in their original positions without tiling. This\nmay lead to artifacts if microscope stage positions are not precise.\n- No Tiling: Each field of view is written as a single OME-Zarr.",
                "title": "Tiling Mode"
              },
              "writer_mode": {
                "$ref": "#/$defs/WriterMode",
                "default": "By FOV",
                "description": "Mode for writing data during conversion.\n- By Tile: Write data one tile at a time. This consumes less memory,\nbut may be slower.\n- By Tile (Using Dask): Write tiles in parallel using Dask. This is\nusually faster than writing by tile sequentially, but may consume more\nmemory.\n- By FOV: Write data one field of view at a time. This may the best\ncompromise between speed and memory usage in most cases.\n- By FOV (Using Dask): Write fields of view in parallel using Dask.\nThis is usually faster than writing by FOV sequentially,\nbut may consume more memory.\n- In Memory: Load all data into memory before writing.",
                "title": "Writer Mode"
              },
              "alignment_correction": {
                "$ref": "#/$defs/AlignmentCorrections",
                "default": {
                  "align_xy": false,
                  "align_z": false,
                  "align_t": false
                },
                "description": "Alignment correction options.",
                "title": "Alignment Corrections"
              },
              "omezarr_options": {
                "$ref": "#/$defs/OmeZarrOptions",
                "default": {
                  "num_levels": 5,
                  "chunks": {
                    "c_chunk": 1,
                    "mode": "Same as FOV",
                    "t_chunk": 1,
                    "xy_scaling": "1",
                    "z_chunk": 10
                  },
                  "ngff_version": "0.4",
                  "table_backend": "anndata"
                },
                "description": "Options specific to OME-Zarr writing.",
                "title": "OME-Zarr Options"
              },
              "temp_json_options": {
                "$ref": "#/$defs/TempJsonOptions",
                "default": {
                  "temp_url": "{zarr_dir}/_tmp_json"
                },
                "description": "Options for temporary JSON storage.",
                "title": "Temporary JSON Options"
              }
            },
            "title": "ConverterOptions",
            "type": "object"
          },
          "DataTypeEnum": {
            "description": "Data type enumeration.",
            "enum": [
              "uint8",
              "uint16",
              "uint32"
            ],
            "title": "DataTypeEnum",
            "type": "string"
          },
          "DefaultColors": {
            "description": "Default colors for the channels.",
            "enum": [
              "Blue (0000FF)",
              "Red (FF0000)",
              "Yellow (FFFF00)",
              "Magenta (FF00FF)",
              "Cyan (00FFFF)",
              "Gray (808080)",
              "Green (00FF00)",
              "Orange (FF8000)",
              "Purple (8000FF)",
              "Teal (008080)",
              "Lime (00FF80)",
              "Amber (FFBF00)",
              "Pink (FF0080)",
              "Navy (000080)",
              "Maroon (800000)",
              "Olive (808000)",
              "Coral (FF7F50)",
              "Violet (8000FF)"
            ],
            "title": "DefaultColors",
            "type": "string"
          },
          "FixedSizeChunking": {
            "description": "Chunking strategy with fixed chunk sizes.",
            "properties": {
              "mode": {
                "const": "Fixed Size",
                "default": "Fixed Size",
                "description": "mode: Fixed size chunking.",
                "title": "Mode",
                "type": "string"
              },
              "xy_chunk": {
                "default": 4096,
                "description": "xy_chunk: Chunk size for XY dimensions.",
                "minimum": 1,
                "title": "Chunk Size for XY",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "description": "z_chunk: Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "c_chunk: Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "t_chunk: Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FixedSizeChunking",
            "type": "object"
          },
          "FovBasedChunking": {
            "description": "Chunking strategy that matches the field of view.",
            "properties": {
              "mode": {
                "const": "Same as FOV",
                "default": "Same as FOV",
                "description": "Chunking based on FOV size.",
                "title": "Mode",
                "type": "string"
              },
              "xy_scaling": {
                "$ref": "#/$defs/Scalings",
                "default": "1",
                "description": "Scaling factor for XY chunk size. If set to 1, chunk size matches\nFOV size. If set to 0.5, chunk size is half the FOV size\n(smaller chunks, more files). If set to 2, chunk size is double the FOV\nsize (larger chunks, less files).",
                "title": "XY Scaling Factor"
              },
              "z_chunk": {
                "default": 10,
                "description": "Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FovBasedChunking",
            "type": "object"
          },
          "OmeZarrOptions": {
            "additionalProperties": false,
            "description": "Options specific to OME-Zarr writing.",
            "properties": {
              "num_levels": {
                "default": 5,
                "minimum": 1,
                "title": "Num Levels",
                "type": "integer"
              },
              "chunks": {
                "default": {
                  "mode": "Same as FOV",
                  "xy_scaling": "1",
                  "z_chunk": 10,
                  "c_chunk": 1,
                  "t_chunk": 1
                },
                "discriminator": {
                  "mapping": {
                    "Fixed Size": "#/$defs/FixedSizeChunking",
                    "Same as FOV": "#/$defs/FovBasedChunking"
                  },
                  "propertyName": "mode"
                },
                "oneOf": [
                  {
                    "$ref": "#/$defs/FovBasedChunking"
                  },
                  {
                    "$ref": "#/$defs/FixedSizeChunking"
                  }
                ],
                "title": "Chunking Strategy"
              },
              "ngff_version": {
                "default": "0.4",
                "enum": [
                  "0.4",
                  "0.5"
                ],
                "title": "Ngff Version",
                "type": "string"
              },
              "table_backend": {
                "$ref": "#/$defs/BackendType",
                "default": "anndata",
                "title": "Table Backend"
              }
            },
            "title": "OmeZarrOptions",
            "type": "object"
          },
          "OverwriteMode": {
            "enum": [
              "No Overwrite",
              "Overwrite",
              "Extend"
            ],
            "title": "OverwriteMode",
            "type": "string",
            "description": "Missing description for OverwriteMode."
          },
          "PixelSizeModel": {
            "description": "Pixel size model 2.",
            "properties": {
              "pixelsize": {
                "description": "Pixel size in micrometers.",
                "title": "Pixelsize",
                "type": "number"
              },
              "z_spacing": {
                "description": "Z spacing in micrometers.",
                "title": "Z Spacing",
                "type": "number"
              },
              "t_spacing": {
                "description": "Time spacing in seconds.",
                "title": "T Spacing",
                "type": "number"
              }
            },
            "required": [
              "pixelsize",
              "z_spacing",
              "t_spacing"
            ],
            "title": "PixelSizeModel",
            "type": "object"
          },
          "RegexExcludeFilter": {
            "description": "Regex exclude filter model.",
            "properties": {
              "name": {
                "const": "Path Regex Exclude Filter",
                "default": "Path Regex Exclude Filter",
                "title": "Name",
                "type": "string"
              },
              "regex": {
                "title": "Regex",
                "type": "string"
              }
            },
            "required": [
              "regex"
            ],
            "title": "RegexExcludeFilter",
            "type": "object"
          },
          "RegexIncludeFilter": {
            "description": "Regex include filter model.",
            "properties": {
              "name": {
                "const": "Path Regex Include Filter",
                "default": "Path Regex Include Filter",
                "title": "Name",
                "type": "string"
              },
              "regex": {
                "title": "Regex",
                "type": "string"
              }
            },
            "required": [
              "regex"
            ],
            "title": "RegexIncludeFilter",
            "type": "object"
          },
          "Scalings": {
            "enum": [
              "0.25",
              "0.5",
              "1",
              "2",
              "4"
            ],
            "title": "Scalings",
            "type": "string",
            "description": "Missing description for Scalings."
          },
          "ScanRAcquisitionModel": {
            "description": "Acquisition details for the Olympus ScanR microscope data.",
            "properties": {
              "path": {
                "description": "Path to the acquisition directory. Should contain MeasurementData.mlf and\nMeasurementDetail.mrf files.",
                "title": "Path",
                "type": "string"
              },
              "plate_name": {
                "description": "Optional custom name for the plate. If not provided, the name will be the acquisition\ndirectory name.",
                "title": "Plate Name",
                "type": "string"
              },
              "acquisition_id": {
                "default": 0,
                "description": "Acquisition ID, used to identify the acquisition in case of multiple acquisitions.",
                "minimum": 0,
                "title": "Acquisition Id",
                "type": "integer"
              },
              "advanced": {
                "$ref": "#/$defs/AcquisitionOptions",
                "default": {
                  "channels": null,
                  "pixel_info": null,
                  "condition_table_path": null,
                  "axes": null,
                  "data_type": null,
                  "stage_corrections": {
                    "flip_x": false,
                    "flip_y": false,
                    "swap_xy": false
                  },
                  "filters": []
                },
                "description": "Advanced acquisition options.",
                "title": "Advanced"
              },
              "layout": {
                "default": "96-well",
                "enum": [
                  "24-well",
                  "48-well",
                  "96-well",
                  "384-well"
                ],
                "title": "Layout",
                "type": "string"
              }
            },
            "required": [
              "path"
            ],
            "title": "ScanRAcquisitionModel",
            "type": "object"
          },
          "StageCorrections": {
            "additionalProperties": false,
            "description": "Stage orientation corrections.",
            "properties": {
              "flip_x": {
                "default": false,
                "title": "Flip X",
                "type": "boolean"
              },
              "flip_y": {
                "default": false,
                "title": "Flip Y",
                "type": "boolean"
              },
              "swap_xy": {
                "default": false,
                "title": "Swap XY",
                "type": "boolean"
              }
            },
            "title": "StageCorrections",
            "type": "object"
          },
          "TempJsonOptions": {
            "description": "Options for temporary JSON storage during conversion.",
            "properties": {
              "temp_url": {
                "default": "{zarr_dir}/_tmp_json",
                "title": "Temp Url",
                "type": "string"
              }
            },
            "title": "TempJsonOptions",
            "type": "object"
          },
          "TilingMode": {
            "enum": [
              "Auto",
              "Snap to Grid",
              "Snap to Corners",
              "Inplace",
              "No Tiling"
            ],
            "title": "TilingMode",
            "type": "string",
            "description": "Missing description for TilingMode."
          },
          "WellFilter": {
            "description": "Well filter model.",
            "properties": {
              "name": {
                "const": "Well Filter",
                "default": "Well Filter",
                "title": "Name",
                "type": "string"
              },
              "wells_to_remove": {
                "items": {
                  "type": "string"
                },
                "title": "Wells To Remove",
                "type": "array"
              }
            },
            "required": [
              "wells_to_remove"
            ],
            "title": "WellFilter",
            "type": "object"
          },
          "WriterMode": {
            "enum": [
              "By Tile",
              "By FOV",
              "By FOV (Using Dask)",
              "By Tile (Using Dask)",
              "In Memory"
            ],
            "title": "WriterMode",
            "type": "string",
            "description": "Missing description for WriterMode."
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "Directory to store the Zarr files."
          },
          "acquisitions": {
            "items": {
              "$ref": "#/$defs/ScanRAcquisitionModel"
            },
            "title": "Acquisitions",
            "type": "array",
            "description": "List of raw acquisitions to convert to OME-Zarr."
          },
          "converter_options": {
            "$ref": "#/$defs/ConverterOptions",
            "default": {
              "tiling_mode": "Auto",
              "writer_mode": "By FOV",
              "alignment_correction": {
                "align_t": false,
                "align_xy": false,
                "align_z": false
              },
              "omezarr_options": {
                "chunks": {
                  "c_chunk": 1,
                  "mode": "Same as FOV",
                  "t_chunk": 1,
                  "xy_scaling": "1",
                  "z_chunk": 10
                },
                "ngff_version": "0.4",
                "num_levels": 5,
                "table_backend": "anndata"
              },
              "temp_json_options": {
                "temp_url": "{zarr_dir}/_tmp_json"
              }
            },
            "title": "Converter Options",
            "description": "Advanced converter options."
          },
          "overwrite": {
            "$ref": "#/$defs/OverwriteMode",
            "default": "No Overwrite",
            "title": "Overwrite",
            "description": "Overwrite mode for existing data. - \"No Overwrite\": Do not overwrite existing data. - \"Overwrite\": Remove and replace existing data. - \"Extend\": Extend existing data without removing it. Default is \"No Overwrite\"."
          }
        },
        "required": [
          "zarr_dir",
          "acquisitions"
        ],
        "type": "object",
        "title": "ConvertScanrInitTask"
      },
      "args_schema_parallel": {
        "$defs": {
          "AlignmentCorrections": {
            "additionalProperties": false,
            "description": "Alignment correction for stage positions.",
            "properties": {
              "align_xy": {
                "default": false,
                "description": "Whether to align the positions in the XY plane by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align XY",
                "type": "boolean"
              },
              "align_z": {
                "default": false,
                "description": "Whether to align the positions in the Z axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align Z",
                "type": "boolean"
              },
              "align_t": {
                "default": false,
                "description": "Whether to align the positions in the T axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align T",
                "type": "boolean"
              }
            },
            "title": "AlignmentCorrections",
            "type": "object"
          },
          "BackendType": {
            "enum": [
              "anndata",
              "json",
              "csv",
              "parquet"
            ],
            "title": "BackendType",
            "type": "string",
            "description": "Missing description for BackendType."
          },
          "ConvertParallelInitArgs": {
            "description": "Arguments for the compute task.",
            "properties": {
              "tiled_image_json_dump_url": {
                "title": "Tiled Image Json Dump Url",
                "type": "string"
              },
              "converter_options": {
                "$ref": "#/$defs/ConverterOptions",
                "title": "Converter_Options"
              },
              "overwrite_mode": {
                "$ref": "#/$defs/OverwriteMode",
                "default": "No Overwrite",
                "title": "Overwrite_Mode"
              }
            },
            "required": [
              "tiled_image_json_dump_url",
              "converter_options"
            ],
            "title": "ConvertParallelInitArgs",
            "type": "object"
          },
          "ConverterOptions": {
            "additionalProperties": false,
            "description": "Options for the OME-Zarr conversion process.",
            "properties": {
              "tiling_mode": {
                "$ref": "#/$defs/TilingMode",
                "default": "Auto",
                "description": "Tiling mode to use during conversion.\n- Auto: Automatically determine if Snap to Grid is possible,\notherwise use Snap to Corners.\n- Snap to Grid: Tile images to fit a regular grid. This is\nonly possible if image positions align to a grid (potentially with overlap).\n- Snap to Corners: Tile images to fit a grid defined by the corner\npositions.\n- Inplace: Write tiles in their original positions without tiling. This\nmay lead to artifacts if microscope stage positions are not precise.\n- No Tiling: Each field of view is written as a single OME-Zarr.",
                "title": "Tiling Mode"
              },
              "writer_mode": {
                "$ref": "#/$defs/WriterMode",
                "default": "By FOV",
                "description": "Mode for writing data during conversion.\n- By Tile: Write data one tile at a time. This consumes less memory,\nbut may be slower.\n- By Tile (Using Dask): Write tiles in parallel using Dask. This is\nusually faster than writing by tile sequentially, but may consume more\nmemory.\n- By FOV: Write data one field of view at a time. This may the best\ncompromise between speed and memory usage in most cases.\n- By FOV (Using Dask): Write fields of view in parallel using Dask.\nThis is usually faster than writing by FOV sequentially,\nbut may consume more memory.\n- In Memory: Load all data into memory before writing.",
                "title": "Writer Mode"
              },
              "alignment_correction": {
                "$ref": "#/$defs/AlignmentCorrections",
                "default": {
                  "align_xy": false,
                  "align_z": false,
                  "align_t": false
                },
                "description": "Alignment correction options.",
                "title": "Alignment Corrections"
              },
              "omezarr_options": {
                "$ref": "#/$defs/OmeZarrOptions",
                "default": {
                  "num_levels": 5,
                  "chunks": {
                    "c_chunk": 1,
                    "mode": "Same as FOV",
                    "t_chunk": 1,
                    "xy_scaling": "1",
                    "z_chunk": 10
                  },
                  "ngff_version": "0.4",
                  "table_backend": "anndata"
                },
                "description": "Options specific to OME-Zarr writing.",
                "title": "OME-Zarr Options"
              },
              "temp_json_options": {
                "$ref": "#/$defs/TempJsonOptions",
                "default": {
                  "temp_url": "{zarr_dir}/_tmp_json"
                },
                "description": "Options for temporary JSON storage.",
                "title": "Temporary JSON Options"
              }
            },
            "title": "ConverterOptions",
            "type": "object"
          },
          "FixedSizeChunking": {
            "description": "Chunking strategy with fixed chunk sizes.",
            "properties": {
              "mode": {
                "const": "Fixed Size",
                "default": "Fixed Size",
                "description": "mode: Fixed size chunking.",
                "title": "Mode",
                "type": "string"
              },
              "xy_chunk": {
                "default": 4096,
                "description": "xy_chunk: Chunk size for XY dimensions.",
                "minimum": 1,
                "title": "Chunk Size for XY",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "description": "z_chunk: Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "c_chunk: Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "t_chunk: Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FixedSizeChunking",
            "type": "object"
          },
          "FovBasedChunking": {
            "description": "Chunking strategy that matches the field of view.",
            "properties": {
              "mode": {
                "const": "Same as FOV",
                "default": "Same as FOV",
                "description": "Chunking based on FOV size.",
                "title": "Mode",
                "type": "string"
              },
              "xy_scaling": {
                "$ref": "#/$defs/Scalings",
                "default": "1",
                "description": "Scaling factor for XY chunk size. If set to 1, chunk size matches\nFOV size. If set to 0.5, chunk size is half the FOV size\n(smaller chunks, more files). If set to 2, chunk size is double the FOV\nsize (larger chunks, less files).",
                "title": "XY Scaling Factor"
              },
              "z_chunk": {
                "default": 10,
                "description": "Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FovBasedChunking",
            "type": "object"
          },
          "OmeZarrOptions": {
            "additionalProperties": false,
            "description": "Options specific to OME-Zarr writing.",
            "properties": {
              "num_levels": {
                "default": 5,
                "minimum": 1,
                "title": "Num Levels",
                "type": "integer"
              },
              "chunks": {
                "default": {
                  "mode": "Same as FOV",
                  "xy_scaling": "1",
                  "z_chunk": 10,
                  "c_chunk": 1,
                  "t_chunk": 1
                },
                "discriminator": {
                  "mapping": {
                    "Fixed Size": "#/$defs/FixedSizeChunking",
                    "Same as FOV": "#/$defs/FovBasedChunking"
                  },
                  "propertyName": "mode"
                },
                "oneOf": [
                  {
                    "$ref": "#/$defs/FovBasedChunking"
                  },
                  {
                    "$ref": "#/$defs/FixedSizeChunking"
                  }
                ],
                "title": "Chunking Strategy"
              },
              "ngff_version": {
                "default": "0.4",
                "enum": [
                  "0.4",
                  "0.5"
                ],
                "title": "Ngff Version",
                "type": "string"
              },
              "table_backend": {
                "$ref": "#/$defs/BackendType",
                "default": "anndata",
                "title": "Table Backend"
              }
            },
            "title": "OmeZarrOptions",
            "type": "object"
          },
          "OverwriteMode": {
            "enum": [
              "No Overwrite",
              "Overwrite",
              "Extend"
            ],
            "title": "OverwriteMode",
            "type": "string",
            "description": "Missing description for OverwriteMode."
          },
          "Scalings": {
            "enum": [
              "0.25",
              "0.5",
              "1",
              "2",
              "4"
            ],
            "title": "Scalings",
            "type": "string",
            "description": "Missing description for Scalings."
          },
          "TempJsonOptions": {
            "description": "Options for temporary JSON storage during conversion.",
            "properties": {
              "temp_url": {
                "default": "{zarr_dir}/_tmp_json",
                "title": "Temp Url",
                "type": "string"
              }
            },
            "title": "TempJsonOptions",
            "type": "object"
          },
          "TilingMode": {
            "enum": [
              "Auto",
              "Snap to Grid",
              "Snap to Corners",
              "Inplace",
              "No Tiling"
            ],
            "title": "TilingMode",
            "type": "string",
            "description": "Missing description for TilingMode."
          },
          "WriterMode": {
            "enum": [
              "By Tile",
              "By FOV",
              "By FOV (Using Dask)",
              "By Tile (Using Dask)",
              "In Memory"
            ],
            "title": "WriterMode",
            "type": "string",
            "description": "Missing description for WriterMode."
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "URL to the OME-Zarr file."
          },
          "init_args": {
            "$ref": "#/$defs/ConvertParallelInitArgs",
            "title": "Init Args",
            "description": "Arguments for the compute task."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "ImageInPlateComputeTask"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-uzh-converters/stable"
    },
    {
      "name": "Convert Yokogawa CQ3K Plate to OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Yokogawa",
        "CQ3K",
        "Plate converter"
      ],
      "docs_info": "### Purpose\n\n- Convert images acquired with a Yokogawa CQ3K / CellVoyager microscope to an OME-Zarr Plate.\n\n### Outputs\n\n- An OME-Zarr Plate.\n- If the acquisition contains multiple Z-image processing types (e.g., `focus`, `maximum_projection`), a separate plate is created for each type.\n\n### Limitations\n\n- This task has been tested on a limited set of acquisitions. It may not work on all Yokogawa CQ3K acquisitions.\n\n### Expected inputs\n\nThe following directory structure is expected:\n\n```text\nmy_acquisition/\n\u251c\u2500\u2500 MeasurementData.mlf      # Image measurement records (required)\n\u251c\u2500\u2500 MeasurementDetail.mrf    # Acquisition details and channel info (required)\n\u2514\u2500\u2500 <subdirectories>/\n    \u251c\u2500\u2500 image_001.tif\n    \u2514\u2500\u2500 ...\n```\n\nThe TIFF file paths are referenced inside `MeasurementData.mlf` and can be in subdirectories relative to the acquisition directory.\n",
      "type": "converter_compound",
      "executable_non_parallel": "cq3k/convert_cq3k_init_task.py",
      "executable_parallel": "common/image_in_plate_compute_task.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "AcquisitionOptions": {
            "description": "Acquisition options for conversion.",
            "properties": {
              "channels": {
                "description": "List of channel information.",
                "items": {
                  "$ref": "#/$defs/ChannelInfo"
                },
                "title": "Channels",
                "type": "array"
              },
              "pixel_info": {
                "$ref": "#/$defs/PixelSizeModel",
                "description": "Pixel size information.",
                "title": "Pixel Size Information"
              },
              "condition_table_path": {
                "description": "Optional path to a condition table CSV file.",
                "title": "Condition Table Path",
                "type": "string"
              },
              "axes": {
                "description": "Axes to use for the image data, e.g. \"czyx\".",
                "title": "Axes",
                "type": "string"
              },
              "data_type": {
                "$ref": "#/$defs/DataTypeEnum",
                "description": "Data type of the image data.",
                "title": "Data Type"
              },
              "stage_corrections": {
                "$ref": "#/$defs/StageCorrections",
                "default": {
                  "flip_x": false,
                  "flip_y": false,
                  "swap_xy": false
                },
                "description": "Stage orientation corrections.",
                "title": "Stage Corrections"
              },
              "filters": {
                "default": [],
                "description": "List of filters to apply.",
                "items": {
                  "discriminator": {
                    "mapping": {
                      "Path Regex Exclude Filter": "#/$defs/RegexExcludeFilter",
                      "Path Regex Include Filter": "#/$defs/RegexIncludeFilter",
                      "Well Filter": "#/$defs/WellFilter"
                    },
                    "propertyName": "name"
                  },
                  "oneOf": [
                    {
                      "$ref": "#/$defs/RegexExcludeFilter"
                    },
                    {
                      "$ref": "#/$defs/RegexIncludeFilter"
                    },
                    {
                      "$ref": "#/$defs/WellFilter"
                    }
                  ]
                },
                "title": "Filters",
                "type": "array"
              }
            },
            "title": "AcquisitionOptions",
            "type": "object"
          },
          "AlignmentCorrections": {
            "additionalProperties": false,
            "description": "Alignment correction for stage positions.",
            "properties": {
              "align_xy": {
                "default": false,
                "description": "Whether to align the positions in the XY plane by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align XY",
                "type": "boolean"
              },
              "align_z": {
                "default": false,
                "description": "Whether to align the positions in the Z axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align Z",
                "type": "boolean"
              },
              "align_t": {
                "default": false,
                "description": "Whether to align the positions in the T axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align T",
                "type": "boolean"
              }
            },
            "title": "AlignmentCorrections",
            "type": "object"
          },
          "BackendType": {
            "enum": [
              "anndata",
              "json",
              "csv",
              "parquet"
            ],
            "title": "BackendType",
            "type": "string",
            "description": "Missing description for BackendType."
          },
          "CQ3KAcquisitionModel": {
            "description": "Acquisition details for the CQ3K microscope data.",
            "properties": {
              "path": {
                "description": "Path to the acquisition directory. Should contain MeasurementData.mlf and\nMeasurementDetail.mrf files.",
                "title": "Path",
                "type": "string"
              },
              "plate_name": {
                "description": "Optional custom name for the plate. If not provided, the name will be the acquisition\ndirectory name.",
                "title": "Plate Name",
                "type": "string"
              },
              "acquisition_id": {
                "default": 0,
                "description": "Acquisition ID, used to identify the acquisition in case of multiple acquisitions.",
                "minimum": 0,
                "title": "Acquisition Id",
                "type": "integer"
              },
              "advanced": {
                "$ref": "#/$defs/AcquisitionOptions",
                "default": {
                  "channels": null,
                  "pixel_info": null,
                  "condition_table_path": null,
                  "axes": null,
                  "data_type": null,
                  "stage_corrections": {
                    "flip_x": false,
                    "flip_y": false,
                    "swap_xy": false
                  },
                  "filters": []
                },
                "description": "Advanced acquisition options.",
                "title": "Advanced"
              }
            },
            "required": [
              "path"
            ],
            "title": "CQ3KAcquisitionModel",
            "type": "object"
          },
          "ChannelInfo": {
            "description": "Channel information.",
            "properties": {
              "channel_label": {
                "description": "Label of the channel.",
                "title": "Channel Label",
                "type": "string"
              },
              "wavelength_id": {
                "description": "The wavelength ID of the channel.\nThis field can be used in some tasks as alternative to channel_label,\ne.g. for multiplexed acquisitions it can be used for applying illumination\ncorrection based on wavelength ID instead of channel name.",
                "title": "Wavelength Id",
                "type": "string"
              },
              "colors": {
                "$ref": "#/$defs/DefaultColors",
                "default": "Blue (0000FF)",
                "description": "The color associated with the channel, e.g. for visualization purposes.",
                "title": "Colors"
              }
            },
            "required": [
              "channel_label"
            ],
            "title": "ChannelInfo",
            "type": "object"
          },
          "ConverterOptions": {
            "additionalProperties": false,
            "description": "Options for the OME-Zarr conversion process.",
            "properties": {
              "tiling_mode": {
                "$ref": "#/$defs/TilingMode",
                "default": "Auto",
                "description": "Tiling mode to use during conversion.\n- Auto: Automatically determine if Snap to Grid is possible,\notherwise use Snap to Corners.\n- Snap to Grid: Tile images to fit a regular grid. This is\nonly possible if image positions align to a grid (potentially with overlap).\n- Snap to Corners: Tile images to fit a grid defined by the corner\npositions.\n- Inplace: Write tiles in their original positions without tiling. This\nmay lead to artifacts if microscope stage positions are not precise.\n- No Tiling: Each field of view is written as a single OME-Zarr.",
                "title": "Tiling Mode"
              },
              "writer_mode": {
                "$ref": "#/$defs/WriterMode",
                "default": "By FOV",
                "description": "Mode for writing data during conversion.\n- By Tile: Write data one tile at a time. This consumes less memory,\nbut may be slower.\n- By Tile (Using Dask): Write tiles in parallel using Dask. This is\nusually faster than writing by tile sequentially, but may consume more\nmemory.\n- By FOV: Write data one field of view at a time. This may the best\ncompromise between speed and memory usage in most cases.\n- By FOV (Using Dask): Write fields of view in parallel using Dask.\nThis is usually faster than writing by FOV sequentially,\nbut may consume more memory.\n- In Memory: Load all data into memory before writing.",
                "title": "Writer Mode"
              },
              "alignment_correction": {
                "$ref": "#/$defs/AlignmentCorrections",
                "default": {
                  "align_xy": false,
                  "align_z": false,
                  "align_t": false
                },
                "description": "Alignment correction options.",
                "title": "Alignment Corrections"
              },
              "omezarr_options": {
                "$ref": "#/$defs/OmeZarrOptions",
                "default": {
                  "num_levels": 5,
                  "chunks": {
                    "c_chunk": 1,
                    "mode": "Same as FOV",
                    "t_chunk": 1,
                    "xy_scaling": "1",
                    "z_chunk": 10
                  },
                  "ngff_version": "0.4",
                  "table_backend": "anndata"
                },
                "description": "Options specific to OME-Zarr writing.",
                "title": "OME-Zarr Options"
              },
              "temp_json_options": {
                "$ref": "#/$defs/TempJsonOptions",
                "default": {
                  "temp_url": "{zarr_dir}/_tmp_json"
                },
                "description": "Options for temporary JSON storage.",
                "title": "Temporary JSON Options"
              }
            },
            "title": "ConverterOptions",
            "type": "object"
          },
          "DataTypeEnum": {
            "description": "Data type enumeration.",
            "enum": [
              "uint8",
              "uint16",
              "uint32"
            ],
            "title": "DataTypeEnum",
            "type": "string"
          },
          "DefaultColors": {
            "description": "Default colors for the channels.",
            "enum": [
              "Blue (0000FF)",
              "Red (FF0000)",
              "Yellow (FFFF00)",
              "Magenta (FF00FF)",
              "Cyan (00FFFF)",
              "Gray (808080)",
              "Green (00FF00)",
              "Orange (FF8000)",
              "Purple (8000FF)",
              "Teal (008080)",
              "Lime (00FF80)",
              "Amber (FFBF00)",
              "Pink (FF0080)",
              "Navy (000080)",
              "Maroon (800000)",
              "Olive (808000)",
              "Coral (FF7F50)",
              "Violet (8000FF)"
            ],
            "title": "DefaultColors",
            "type": "string"
          },
          "FixedSizeChunking": {
            "description": "Chunking strategy with fixed chunk sizes.",
            "properties": {
              "mode": {
                "const": "Fixed Size",
                "default": "Fixed Size",
                "description": "mode: Fixed size chunking.",
                "title": "Mode",
                "type": "string"
              },
              "xy_chunk": {
                "default": 4096,
                "description": "xy_chunk: Chunk size for XY dimensions.",
                "minimum": 1,
                "title": "Chunk Size for XY",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "description": "z_chunk: Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "c_chunk: Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "t_chunk: Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FixedSizeChunking",
            "type": "object"
          },
          "FovBasedChunking": {
            "description": "Chunking strategy that matches the field of view.",
            "properties": {
              "mode": {
                "const": "Same as FOV",
                "default": "Same as FOV",
                "description": "Chunking based on FOV size.",
                "title": "Mode",
                "type": "string"
              },
              "xy_scaling": {
                "$ref": "#/$defs/Scalings",
                "default": "1",
                "description": "Scaling factor for XY chunk size. If set to 1, chunk size matches\nFOV size. If set to 0.5, chunk size is half the FOV size\n(smaller chunks, more files). If set to 2, chunk size is double the FOV\nsize (larger chunks, less files).",
                "title": "XY Scaling Factor"
              },
              "z_chunk": {
                "default": 10,
                "description": "Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FovBasedChunking",
            "type": "object"
          },
          "OmeZarrOptions": {
            "additionalProperties": false,
            "description": "Options specific to OME-Zarr writing.",
            "properties": {
              "num_levels": {
                "default": 5,
                "minimum": 1,
                "title": "Num Levels",
                "type": "integer"
              },
              "chunks": {
                "default": {
                  "mode": "Same as FOV",
                  "xy_scaling": "1",
                  "z_chunk": 10,
                  "c_chunk": 1,
                  "t_chunk": 1
                },
                "discriminator": {
                  "mapping": {
                    "Fixed Size": "#/$defs/FixedSizeChunking",
                    "Same as FOV": "#/$defs/FovBasedChunking"
                  },
                  "propertyName": "mode"
                },
                "oneOf": [
                  {
                    "$ref": "#/$defs/FovBasedChunking"
                  },
                  {
                    "$ref": "#/$defs/FixedSizeChunking"
                  }
                ],
                "title": "Chunking Strategy"
              },
              "ngff_version": {
                "default": "0.4",
                "enum": [
                  "0.4",
                  "0.5"
                ],
                "title": "Ngff Version",
                "type": "string"
              },
              "table_backend": {
                "$ref": "#/$defs/BackendType",
                "default": "anndata",
                "title": "Table Backend"
              }
            },
            "title": "OmeZarrOptions",
            "type": "object"
          },
          "OverwriteMode": {
            "enum": [
              "No Overwrite",
              "Overwrite",
              "Extend"
            ],
            "title": "OverwriteMode",
            "type": "string",
            "description": "Missing description for OverwriteMode."
          },
          "PixelSizeModel": {
            "description": "Pixel size model 2.",
            "properties": {
              "pixelsize": {
                "description": "Pixel size in micrometers.",
                "title": "Pixelsize",
                "type": "number"
              },
              "z_spacing": {
                "description": "Z spacing in micrometers.",
                "title": "Z Spacing",
                "type": "number"
              },
              "t_spacing": {
                "description": "Time spacing in seconds.",
                "title": "T Spacing",
                "type": "number"
              }
            },
            "required": [
              "pixelsize",
              "z_spacing",
              "t_spacing"
            ],
            "title": "PixelSizeModel",
            "type": "object"
          },
          "RegexExcludeFilter": {
            "description": "Regex exclude filter model.",
            "properties": {
              "name": {
                "const": "Path Regex Exclude Filter",
                "default": "Path Regex Exclude Filter",
                "title": "Name",
                "type": "string"
              },
              "regex": {
                "title": "Regex",
                "type": "string"
              }
            },
            "required": [
              "regex"
            ],
            "title": "RegexExcludeFilter",
            "type": "object"
          },
          "RegexIncludeFilter": {
            "description": "Regex include filter model.",
            "properties": {
              "name": {
                "const": "Path Regex Include Filter",
                "default": "Path Regex Include Filter",
                "title": "Name",
                "type": "string"
              },
              "regex": {
                "title": "Regex",
                "type": "string"
              }
            },
            "required": [
              "regex"
            ],
            "title": "RegexIncludeFilter",
            "type": "object"
          },
          "Scalings": {
            "enum": [
              "0.25",
              "0.5",
              "1",
              "2",
              "4"
            ],
            "title": "Scalings",
            "type": "string",
            "description": "Missing description for Scalings."
          },
          "StageCorrections": {
            "additionalProperties": false,
            "description": "Stage orientation corrections.",
            "properties": {
              "flip_x": {
                "default": false,
                "title": "Flip X",
                "type": "boolean"
              },
              "flip_y": {
                "default": false,
                "title": "Flip Y",
                "type": "boolean"
              },
              "swap_xy": {
                "default": false,
                "title": "Swap XY",
                "type": "boolean"
              }
            },
            "title": "StageCorrections",
            "type": "object"
          },
          "TempJsonOptions": {
            "description": "Options for temporary JSON storage during conversion.",
            "properties": {
              "temp_url": {
                "default": "{zarr_dir}/_tmp_json",
                "title": "Temp Url",
                "type": "string"
              }
            },
            "title": "TempJsonOptions",
            "type": "object"
          },
          "TilingMode": {
            "enum": [
              "Auto",
              "Snap to Grid",
              "Snap to Corners",
              "Inplace",
              "No Tiling"
            ],
            "title": "TilingMode",
            "type": "string",
            "description": "Missing description for TilingMode."
          },
          "WellFilter": {
            "description": "Well filter model.",
            "properties": {
              "name": {
                "const": "Well Filter",
                "default": "Well Filter",
                "title": "Name",
                "type": "string"
              },
              "wells_to_remove": {
                "items": {
                  "type": "string"
                },
                "title": "Wells To Remove",
                "type": "array"
              }
            },
            "required": [
              "wells_to_remove"
            ],
            "title": "WellFilter",
            "type": "object"
          },
          "WriterMode": {
            "enum": [
              "By Tile",
              "By FOV",
              "By FOV (Using Dask)",
              "By Tile (Using Dask)",
              "In Memory"
            ],
            "title": "WriterMode",
            "type": "string",
            "description": "Missing description for WriterMode."
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "Directory to store the Zarr files."
          },
          "acquisitions": {
            "items": {
              "$ref": "#/$defs/CQ3KAcquisitionModel"
            },
            "title": "Acquisitions",
            "type": "array",
            "description": "List of raw acquisitions to convert to OME-Zarr."
          },
          "converter_options": {
            "$ref": "#/$defs/ConverterOptions",
            "default": {
              "tiling_mode": "Auto",
              "writer_mode": "By FOV",
              "alignment_correction": {
                "align_t": false,
                "align_xy": false,
                "align_z": false
              },
              "omezarr_options": {
                "chunks": {
                  "c_chunk": 1,
                  "mode": "Same as FOV",
                  "t_chunk": 1,
                  "xy_scaling": "1",
                  "z_chunk": 10
                },
                "ngff_version": "0.4",
                "num_levels": 5,
                "table_backend": "anndata"
              },
              "temp_json_options": {
                "temp_url": "{zarr_dir}/_tmp_json"
              }
            },
            "title": "Converter Options",
            "description": "Advanced converter options."
          },
          "overwrite": {
            "$ref": "#/$defs/OverwriteMode",
            "default": "No Overwrite",
            "title": "Overwrite",
            "description": "Overwrite mode for existing data. - \"No Overwrite\": Do not overwrite existing data. - \"Overwrite\": Remove and replace existing data. - \"Extend\": Extend existing data without removing it. Default is \"No Overwrite\"."
          }
        },
        "required": [
          "zarr_dir",
          "acquisitions"
        ],
        "type": "object",
        "title": "ConvertCq3kInitTask"
      },
      "args_schema_parallel": {
        "$defs": {
          "AlignmentCorrections": {
            "additionalProperties": false,
            "description": "Alignment correction for stage positions.",
            "properties": {
              "align_xy": {
                "default": false,
                "description": "Whether to align the positions in the XY plane by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align XY",
                "type": "boolean"
              },
              "align_z": {
                "default": false,
                "description": "Whether to align the positions in the Z axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align Z",
                "type": "boolean"
              },
              "align_t": {
                "default": false,
                "description": "Whether to align the positions in the T axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align T",
                "type": "boolean"
              }
            },
            "title": "AlignmentCorrections",
            "type": "object"
          },
          "BackendType": {
            "enum": [
              "anndata",
              "json",
              "csv",
              "parquet"
            ],
            "title": "BackendType",
            "type": "string",
            "description": "Missing description for BackendType."
          },
          "ConvertParallelInitArgs": {
            "description": "Arguments for the compute task.",
            "properties": {
              "tiled_image_json_dump_url": {
                "title": "Tiled Image Json Dump Url",
                "type": "string"
              },
              "converter_options": {
                "$ref": "#/$defs/ConverterOptions",
                "title": "Converter_Options"
              },
              "overwrite_mode": {
                "$ref": "#/$defs/OverwriteMode",
                "default": "No Overwrite",
                "title": "Overwrite_Mode"
              }
            },
            "required": [
              "tiled_image_json_dump_url",
              "converter_options"
            ],
            "title": "ConvertParallelInitArgs",
            "type": "object"
          },
          "ConverterOptions": {
            "additionalProperties": false,
            "description": "Options for the OME-Zarr conversion process.",
            "properties": {
              "tiling_mode": {
                "$ref": "#/$defs/TilingMode",
                "default": "Auto",
                "description": "Tiling mode to use during conversion.\n- Auto: Automatically determine if Snap to Grid is possible,\notherwise use Snap to Corners.\n- Snap to Grid: Tile images to fit a regular grid. This is\nonly possible if image positions align to a grid (potentially with overlap).\n- Snap to Corners: Tile images to fit a grid defined by the corner\npositions.\n- Inplace: Write tiles in their original positions without tiling. This\nmay lead to artifacts if microscope stage positions are not precise.\n- No Tiling: Each field of view is written as a single OME-Zarr.",
                "title": "Tiling Mode"
              },
              "writer_mode": {
                "$ref": "#/$defs/WriterMode",
                "default": "By FOV",
                "description": "Mode for writing data during conversion.\n- By Tile: Write data one tile at a time. This consumes less memory,\nbut may be slower.\n- By Tile (Using Dask): Write tiles in parallel using Dask. This is\nusually faster than writing by tile sequentially, but may consume more\nmemory.\n- By FOV: Write data one field of view at a time. This may the best\ncompromise between speed and memory usage in most cases.\n- By FOV (Using Dask): Write fields of view in parallel using Dask.\nThis is usually faster than writing by FOV sequentially,\nbut may consume more memory.\n- In Memory: Load all data into memory before writing.",
                "title": "Writer Mode"
              },
              "alignment_correction": {
                "$ref": "#/$defs/AlignmentCorrections",
                "default": {
                  "align_xy": false,
                  "align_z": false,
                  "align_t": false
                },
                "description": "Alignment correction options.",
                "title": "Alignment Corrections"
              },
              "omezarr_options": {
                "$ref": "#/$defs/OmeZarrOptions",
                "default": {
                  "num_levels": 5,
                  "chunks": {
                    "c_chunk": 1,
                    "mode": "Same as FOV",
                    "t_chunk": 1,
                    "xy_scaling": "1",
                    "z_chunk": 10
                  },
                  "ngff_version": "0.4",
                  "table_backend": "anndata"
                },
                "description": "Options specific to OME-Zarr writing.",
                "title": "OME-Zarr Options"
              },
              "temp_json_options": {
                "$ref": "#/$defs/TempJsonOptions",
                "default": {
                  "temp_url": "{zarr_dir}/_tmp_json"
                },
                "description": "Options for temporary JSON storage.",
                "title": "Temporary JSON Options"
              }
            },
            "title": "ConverterOptions",
            "type": "object"
          },
          "FixedSizeChunking": {
            "description": "Chunking strategy with fixed chunk sizes.",
            "properties": {
              "mode": {
                "const": "Fixed Size",
                "default": "Fixed Size",
                "description": "mode: Fixed size chunking.",
                "title": "Mode",
                "type": "string"
              },
              "xy_chunk": {
                "default": 4096,
                "description": "xy_chunk: Chunk size for XY dimensions.",
                "minimum": 1,
                "title": "Chunk Size for XY",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "description": "z_chunk: Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "c_chunk: Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "t_chunk: Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FixedSizeChunking",
            "type": "object"
          },
          "FovBasedChunking": {
            "description": "Chunking strategy that matches the field of view.",
            "properties": {
              "mode": {
                "const": "Same as FOV",
                "default": "Same as FOV",
                "description": "Chunking based on FOV size.",
                "title": "Mode",
                "type": "string"
              },
              "xy_scaling": {
                "$ref": "#/$defs/Scalings",
                "default": "1",
                "description": "Scaling factor for XY chunk size. If set to 1, chunk size matches\nFOV size. If set to 0.5, chunk size is half the FOV size\n(smaller chunks, more files). If set to 2, chunk size is double the FOV\nsize (larger chunks, less files).",
                "title": "XY Scaling Factor"
              },
              "z_chunk": {
                "default": 10,
                "description": "Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FovBasedChunking",
            "type": "object"
          },
          "OmeZarrOptions": {
            "additionalProperties": false,
            "description": "Options specific to OME-Zarr writing.",
            "properties": {
              "num_levels": {
                "default": 5,
                "minimum": 1,
                "title": "Num Levels",
                "type": "integer"
              },
              "chunks": {
                "default": {
                  "mode": "Same as FOV",
                  "xy_scaling": "1",
                  "z_chunk": 10,
                  "c_chunk": 1,
                  "t_chunk": 1
                },
                "discriminator": {
                  "mapping": {
                    "Fixed Size": "#/$defs/FixedSizeChunking",
                    "Same as FOV": "#/$defs/FovBasedChunking"
                  },
                  "propertyName": "mode"
                },
                "oneOf": [
                  {
                    "$ref": "#/$defs/FovBasedChunking"
                  },
                  {
                    "$ref": "#/$defs/FixedSizeChunking"
                  }
                ],
                "title": "Chunking Strategy"
              },
              "ngff_version": {
                "default": "0.4",
                "enum": [
                  "0.4",
                  "0.5"
                ],
                "title": "Ngff Version",
                "type": "string"
              },
              "table_backend": {
                "$ref": "#/$defs/BackendType",
                "default": "anndata",
                "title": "Table Backend"
              }
            },
            "title": "OmeZarrOptions",
            "type": "object"
          },
          "OverwriteMode": {
            "enum": [
              "No Overwrite",
              "Overwrite",
              "Extend"
            ],
            "title": "OverwriteMode",
            "type": "string",
            "description": "Missing description for OverwriteMode."
          },
          "Scalings": {
            "enum": [
              "0.25",
              "0.5",
              "1",
              "2",
              "4"
            ],
            "title": "Scalings",
            "type": "string",
            "description": "Missing description for Scalings."
          },
          "TempJsonOptions": {
            "description": "Options for temporary JSON storage during conversion.",
            "properties": {
              "temp_url": {
                "default": "{zarr_dir}/_tmp_json",
                "title": "Temp Url",
                "type": "string"
              }
            },
            "title": "TempJsonOptions",
            "type": "object"
          },
          "TilingMode": {
            "enum": [
              "Auto",
              "Snap to Grid",
              "Snap to Corners",
              "Inplace",
              "No Tiling"
            ],
            "title": "TilingMode",
            "type": "string",
            "description": "Missing description for TilingMode."
          },
          "WriterMode": {
            "enum": [
              "By Tile",
              "By FOV",
              "By FOV (Using Dask)",
              "By Tile (Using Dask)",
              "In Memory"
            ],
            "title": "WriterMode",
            "type": "string",
            "description": "Missing description for WriterMode."
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "URL to the OME-Zarr file."
          },
          "init_args": {
            "$ref": "#/$defs/ConvertParallelInitArgs",
            "title": "Init Args",
            "description": "Arguments for the compute task."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "ImageInPlateComputeTask"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-uzh-converters/stable"
    },
    {
      "name": "Convert Operetta Plate to OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Operetta",
        "Plate converter"
      ],
      "docs_info": "### Purpose\n\n- Convert images acquired with a PerkinElmer Operetta / Opera Phenix microscope to an OME-Zarr Plate.\n\n### Outputs\n\n- An OME-Zarr Plate.\n\n### Limitations\n\n- This task has been tested on a limited set of acquisitions. It may not work on all PerkinElmer Operetta acquisitions.\n\n### Expected inputs\n\nThe following directory structure is expected:\n\n```text\nmy_acquisition/\n\u2514\u2500\u2500 Images/\n    \u251c\u2500\u2500 Index.idx.xml        # Metadata file (required)\n    \u251c\u2500\u2500 r01c01f01p01-ch1sk1fk1fl1.tiff\n    \u251c\u2500\u2500 r01c01f01p01-ch2sk1fk1fl1.tiff\n    \u2514\u2500\u2500 ...\n```\n\n`Path` can point to either the base directory (`my_acquisition/`) or directly to the `Images` subdirectory (`my_acquisition/Images/`).\n",
      "type": "converter_compound",
      "executable_non_parallel": "operetta/convert_operetta_init_task.py",
      "executable_parallel": "common/image_in_plate_compute_task.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "AcquisitionOptions": {
            "description": "Acquisition options for conversion.",
            "properties": {
              "channels": {
                "description": "List of channel information.",
                "items": {
                  "$ref": "#/$defs/ChannelInfo"
                },
                "title": "Channels",
                "type": "array"
              },
              "pixel_info": {
                "$ref": "#/$defs/PixelSizeModel",
                "description": "Pixel size information.",
                "title": "Pixel Size Information"
              },
              "condition_table_path": {
                "description": "Optional path to a condition table CSV file.",
                "title": "Condition Table Path",
                "type": "string"
              },
              "axes": {
                "description": "Axes to use for the image data, e.g. \"czyx\".",
                "title": "Axes",
                "type": "string"
              },
              "data_type": {
                "$ref": "#/$defs/DataTypeEnum",
                "description": "Data type of the image data.",
                "title": "Data Type"
              },
              "stage_corrections": {
                "$ref": "#/$defs/StageCorrections",
                "default": {
                  "flip_x": false,
                  "flip_y": false,
                  "swap_xy": false
                },
                "description": "Stage orientation corrections.",
                "title": "Stage Corrections"
              },
              "filters": {
                "default": [],
                "description": "List of filters to apply.",
                "items": {
                  "discriminator": {
                    "mapping": {
                      "Path Regex Exclude Filter": "#/$defs/RegexExcludeFilter",
                      "Path Regex Include Filter": "#/$defs/RegexIncludeFilter",
                      "Well Filter": "#/$defs/WellFilter"
                    },
                    "propertyName": "name"
                  },
                  "oneOf": [
                    {
                      "$ref": "#/$defs/RegexExcludeFilter"
                    },
                    {
                      "$ref": "#/$defs/RegexIncludeFilter"
                    },
                    {
                      "$ref": "#/$defs/WellFilter"
                    }
                  ]
                },
                "title": "Filters",
                "type": "array"
              }
            },
            "title": "AcquisitionOptions",
            "type": "object"
          },
          "AlignmentCorrections": {
            "additionalProperties": false,
            "description": "Alignment correction for stage positions.",
            "properties": {
              "align_xy": {
                "default": false,
                "description": "Whether to align the positions in the XY plane by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align XY",
                "type": "boolean"
              },
              "align_z": {
                "default": false,
                "description": "Whether to align the positions in the Z axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align Z",
                "type": "boolean"
              },
              "align_t": {
                "default": false,
                "description": "Whether to align the positions in the T axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align T",
                "type": "boolean"
              }
            },
            "title": "AlignmentCorrections",
            "type": "object"
          },
          "BackendType": {
            "enum": [
              "anndata",
              "json",
              "csv",
              "parquet"
            ],
            "title": "BackendType",
            "type": "string",
            "description": "Missing description for BackendType."
          },
          "ChannelInfo": {
            "description": "Channel information.",
            "properties": {
              "channel_label": {
                "description": "Label of the channel.",
                "title": "Channel Label",
                "type": "string"
              },
              "wavelength_id": {
                "description": "The wavelength ID of the channel.\nThis field can be used in some tasks as alternative to channel_label,\ne.g. for multiplexed acquisitions it can be used for applying illumination\ncorrection based on wavelength ID instead of channel name.",
                "title": "Wavelength Id",
                "type": "string"
              },
              "colors": {
                "$ref": "#/$defs/DefaultColors",
                "default": "Blue (0000FF)",
                "description": "The color associated with the channel, e.g. for visualization purposes.",
                "title": "Colors"
              }
            },
            "required": [
              "channel_label"
            ],
            "title": "ChannelInfo",
            "type": "object"
          },
          "ConverterOptions": {
            "additionalProperties": false,
            "description": "Options for the OME-Zarr conversion process.",
            "properties": {
              "tiling_mode": {
                "$ref": "#/$defs/TilingMode",
                "default": "Auto",
                "description": "Tiling mode to use during conversion.\n- Auto: Automatically determine if Snap to Grid is possible,\notherwise use Snap to Corners.\n- Snap to Grid: Tile images to fit a regular grid. This is\nonly possible if image positions align to a grid (potentially with overlap).\n- Snap to Corners: Tile images to fit a grid defined by the corner\npositions.\n- Inplace: Write tiles in their original positions without tiling. This\nmay lead to artifacts if microscope stage positions are not precise.\n- No Tiling: Each field of view is written as a single OME-Zarr.",
                "title": "Tiling Mode"
              },
              "writer_mode": {
                "$ref": "#/$defs/WriterMode",
                "default": "By FOV",
                "description": "Mode for writing data during conversion.\n- By Tile: Write data one tile at a time. This consumes less memory,\nbut may be slower.\n- By Tile (Using Dask): Write tiles in parallel using Dask. This is\nusually faster than writing by tile sequentially, but may consume more\nmemory.\n- By FOV: Write data one field of view at a time. This may the best\ncompromise between speed and memory usage in most cases.\n- By FOV (Using Dask): Write fields of view in parallel using Dask.\nThis is usually faster than writing by FOV sequentially,\nbut may consume more memory.\n- In Memory: Load all data into memory before writing.",
                "title": "Writer Mode"
              },
              "alignment_correction": {
                "$ref": "#/$defs/AlignmentCorrections",
                "default": {
                  "align_xy": false,
                  "align_z": false,
                  "align_t": false
                },
                "description": "Alignment correction options.",
                "title": "Alignment Corrections"
              },
              "omezarr_options": {
                "$ref": "#/$defs/OmeZarrOptions",
                "default": {
                  "num_levels": 5,
                  "chunks": {
                    "c_chunk": 1,
                    "mode": "Same as FOV",
                    "t_chunk": 1,
                    "xy_scaling": "1",
                    "z_chunk": 10
                  },
                  "ngff_version": "0.4",
                  "table_backend": "anndata"
                },
                "description": "Options specific to OME-Zarr writing.",
                "title": "OME-Zarr Options"
              },
              "temp_json_options": {
                "$ref": "#/$defs/TempJsonOptions",
                "default": {
                  "temp_url": "{zarr_dir}/_tmp_json"
                },
                "description": "Options for temporary JSON storage.",
                "title": "Temporary JSON Options"
              }
            },
            "title": "ConverterOptions",
            "type": "object"
          },
          "DataTypeEnum": {
            "description": "Data type enumeration.",
            "enum": [
              "uint8",
              "uint16",
              "uint32"
            ],
            "title": "DataTypeEnum",
            "type": "string"
          },
          "DefaultColors": {
            "description": "Default colors for the channels.",
            "enum": [
              "Blue (0000FF)",
              "Red (FF0000)",
              "Yellow (FFFF00)",
              "Magenta (FF00FF)",
              "Cyan (00FFFF)",
              "Gray (808080)",
              "Green (00FF00)",
              "Orange (FF8000)",
              "Purple (8000FF)",
              "Teal (008080)",
              "Lime (00FF80)",
              "Amber (FFBF00)",
              "Pink (FF0080)",
              "Navy (000080)",
              "Maroon (800000)",
              "Olive (808000)",
              "Coral (FF7F50)",
              "Violet (8000FF)"
            ],
            "title": "DefaultColors",
            "type": "string"
          },
          "FixedSizeChunking": {
            "description": "Chunking strategy with fixed chunk sizes.",
            "properties": {
              "mode": {
                "const": "Fixed Size",
                "default": "Fixed Size",
                "description": "mode: Fixed size chunking.",
                "title": "Mode",
                "type": "string"
              },
              "xy_chunk": {
                "default": 4096,
                "description": "xy_chunk: Chunk size for XY dimensions.",
                "minimum": 1,
                "title": "Chunk Size for XY",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "description": "z_chunk: Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "c_chunk: Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "t_chunk: Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FixedSizeChunking",
            "type": "object"
          },
          "FovBasedChunking": {
            "description": "Chunking strategy that matches the field of view.",
            "properties": {
              "mode": {
                "const": "Same as FOV",
                "default": "Same as FOV",
                "description": "Chunking based on FOV size.",
                "title": "Mode",
                "type": "string"
              },
              "xy_scaling": {
                "$ref": "#/$defs/Scalings",
                "default": "1",
                "description": "Scaling factor for XY chunk size. If set to 1, chunk size matches\nFOV size. If set to 0.5, chunk size is half the FOV size\n(smaller chunks, more files). If set to 2, chunk size is double the FOV\nsize (larger chunks, less files).",
                "title": "XY Scaling Factor"
              },
              "z_chunk": {
                "default": 10,
                "description": "Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FovBasedChunking",
            "type": "object"
          },
          "OmeZarrOptions": {
            "additionalProperties": false,
            "description": "Options specific to OME-Zarr writing.",
            "properties": {
              "num_levels": {
                "default": 5,
                "minimum": 1,
                "title": "Num Levels",
                "type": "integer"
              },
              "chunks": {
                "default": {
                  "mode": "Same as FOV",
                  "xy_scaling": "1",
                  "z_chunk": 10,
                  "c_chunk": 1,
                  "t_chunk": 1
                },
                "discriminator": {
                  "mapping": {
                    "Fixed Size": "#/$defs/FixedSizeChunking",
                    "Same as FOV": "#/$defs/FovBasedChunking"
                  },
                  "propertyName": "mode"
                },
                "oneOf": [
                  {
                    "$ref": "#/$defs/FovBasedChunking"
                  },
                  {
                    "$ref": "#/$defs/FixedSizeChunking"
                  }
                ],
                "title": "Chunking Strategy"
              },
              "ngff_version": {
                "default": "0.4",
                "enum": [
                  "0.4",
                  "0.5"
                ],
                "title": "Ngff Version",
                "type": "string"
              },
              "table_backend": {
                "$ref": "#/$defs/BackendType",
                "default": "anndata",
                "title": "Table Backend"
              }
            },
            "title": "OmeZarrOptions",
            "type": "object"
          },
          "OperettaAcquisitionModel": {
            "description": "Acquisition details for the Operetta microscope data.",
            "properties": {
              "path": {
                "description": "Path to the acquisition directory. Should contain MeasurementData.mlf and\nMeasurementDetail.mrf files.",
                "title": "Path",
                "type": "string"
              },
              "plate_name": {
                "description": "Optional custom name for the plate. If not provided, the name will be the acquisition\ndirectory name.",
                "title": "Plate Name",
                "type": "string"
              },
              "acquisition_id": {
                "default": 0,
                "description": "Acquisition ID, used to identify the acquisition in case of multiple acquisitions.",
                "minimum": 0,
                "title": "Acquisition Id",
                "type": "integer"
              },
              "advanced": {
                "$ref": "#/$defs/AcquisitionOptions",
                "default": {
                  "channels": null,
                  "pixel_info": null,
                  "condition_table_path": null,
                  "axes": null,
                  "data_type": null,
                  "stage_corrections": {
                    "flip_x": false,
                    "flip_y": false,
                    "swap_xy": false
                  },
                  "filters": []
                },
                "description": "Advanced acquisition options.",
                "title": "Advanced"
              }
            },
            "required": [
              "path"
            ],
            "title": "OperettaAcquisitionModel",
            "type": "object"
          },
          "OverwriteMode": {
            "enum": [
              "No Overwrite",
              "Overwrite",
              "Extend"
            ],
            "title": "OverwriteMode",
            "type": "string",
            "description": "Missing description for OverwriteMode."
          },
          "PixelSizeModel": {
            "description": "Pixel size model 2.",
            "properties": {
              "pixelsize": {
                "description": "Pixel size in micrometers.",
                "title": "Pixelsize",
                "type": "number"
              },
              "z_spacing": {
                "description": "Z spacing in micrometers.",
                "title": "Z Spacing",
                "type": "number"
              },
              "t_spacing": {
                "description": "Time spacing in seconds.",
                "title": "T Spacing",
                "type": "number"
              }
            },
            "required": [
              "pixelsize",
              "z_spacing",
              "t_spacing"
            ],
            "title": "PixelSizeModel",
            "type": "object"
          },
          "RegexExcludeFilter": {
            "description": "Regex exclude filter model.",
            "properties": {
              "name": {
                "const": "Path Regex Exclude Filter",
                "default": "Path Regex Exclude Filter",
                "title": "Name",
                "type": "string"
              },
              "regex": {
                "title": "Regex",
                "type": "string"
              }
            },
            "required": [
              "regex"
            ],
            "title": "RegexExcludeFilter",
            "type": "object"
          },
          "RegexIncludeFilter": {
            "description": "Regex include filter model.",
            "properties": {
              "name": {
                "const": "Path Regex Include Filter",
                "default": "Path Regex Include Filter",
                "title": "Name",
                "type": "string"
              },
              "regex": {
                "title": "Regex",
                "type": "string"
              }
            },
            "required": [
              "regex"
            ],
            "title": "RegexIncludeFilter",
            "type": "object"
          },
          "Scalings": {
            "enum": [
              "0.25",
              "0.5",
              "1",
              "2",
              "4"
            ],
            "title": "Scalings",
            "type": "string",
            "description": "Missing description for Scalings."
          },
          "StageCorrections": {
            "additionalProperties": false,
            "description": "Stage orientation corrections.",
            "properties": {
              "flip_x": {
                "default": false,
                "title": "Flip X",
                "type": "boolean"
              },
              "flip_y": {
                "default": false,
                "title": "Flip Y",
                "type": "boolean"
              },
              "swap_xy": {
                "default": false,
                "title": "Swap XY",
                "type": "boolean"
              }
            },
            "title": "StageCorrections",
            "type": "object"
          },
          "TempJsonOptions": {
            "description": "Options for temporary JSON storage during conversion.",
            "properties": {
              "temp_url": {
                "default": "{zarr_dir}/_tmp_json",
                "title": "Temp Url",
                "type": "string"
              }
            },
            "title": "TempJsonOptions",
            "type": "object"
          },
          "TilingMode": {
            "enum": [
              "Auto",
              "Snap to Grid",
              "Snap to Corners",
              "Inplace",
              "No Tiling"
            ],
            "title": "TilingMode",
            "type": "string",
            "description": "Missing description for TilingMode."
          },
          "WellFilter": {
            "description": "Well filter model.",
            "properties": {
              "name": {
                "const": "Well Filter",
                "default": "Well Filter",
                "title": "Name",
                "type": "string"
              },
              "wells_to_remove": {
                "items": {
                  "type": "string"
                },
                "title": "Wells To Remove",
                "type": "array"
              }
            },
            "required": [
              "wells_to_remove"
            ],
            "title": "WellFilter",
            "type": "object"
          },
          "WriterMode": {
            "enum": [
              "By Tile",
              "By FOV",
              "By FOV (Using Dask)",
              "By Tile (Using Dask)",
              "In Memory"
            ],
            "title": "WriterMode",
            "type": "string",
            "description": "Missing description for WriterMode."
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "Directory to store the Zarr files."
          },
          "acquisitions": {
            "items": {
              "$ref": "#/$defs/OperettaAcquisitionModel"
            },
            "title": "Acquisitions",
            "type": "array",
            "description": "List of raw acquisitions to convert to OME-Zarr."
          },
          "converter_options": {
            "$ref": "#/$defs/ConverterOptions",
            "default": {
              "tiling_mode": "Auto",
              "writer_mode": "By FOV",
              "alignment_correction": {
                "align_t": false,
                "align_xy": false,
                "align_z": false
              },
              "omezarr_options": {
                "chunks": {
                  "c_chunk": 1,
                  "mode": "Same as FOV",
                  "t_chunk": 1,
                  "xy_scaling": "1",
                  "z_chunk": 10
                },
                "ngff_version": "0.4",
                "num_levels": 5,
                "table_backend": "anndata"
              },
              "temp_json_options": {
                "temp_url": "{zarr_dir}/_tmp_json"
              }
            },
            "title": "Converter Options",
            "description": "Advanced converter options."
          },
          "overwrite": {
            "$ref": "#/$defs/OverwriteMode",
            "default": "No Overwrite",
            "title": "Overwrite",
            "description": "Overwrite mode for existing data. - \"No Overwrite\": Do not overwrite existing data. - \"Overwrite\": Remove and replace existing data. - \"Extend\": Extend existing data without removing it. Default is \"No Overwrite\"."
          }
        },
        "required": [
          "zarr_dir",
          "acquisitions"
        ],
        "type": "object",
        "title": "ConvertOperettaInitTask"
      },
      "args_schema_parallel": {
        "$defs": {
          "AlignmentCorrections": {
            "additionalProperties": false,
            "description": "Alignment correction for stage positions.",
            "properties": {
              "align_xy": {
                "default": false,
                "description": "Whether to align the positions in the XY plane by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align XY",
                "type": "boolean"
              },
              "align_z": {
                "default": false,
                "description": "Whether to align the positions in the Z axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align Z",
                "type": "boolean"
              },
              "align_t": {
                "default": false,
                "description": "Whether to align the positions in the T axis by FOV.\nThis addresses minor imprecision that often occurs during\nimage acquisition.",
                "title": "Align T",
                "type": "boolean"
              }
            },
            "title": "AlignmentCorrections",
            "type": "object"
          },
          "BackendType": {
            "enum": [
              "anndata",
              "json",
              "csv",
              "parquet"
            ],
            "title": "BackendType",
            "type": "string",
            "description": "Missing description for BackendType."
          },
          "ConvertParallelInitArgs": {
            "description": "Arguments for the compute task.",
            "properties": {
              "tiled_image_json_dump_url": {
                "title": "Tiled Image Json Dump Url",
                "type": "string"
              },
              "converter_options": {
                "$ref": "#/$defs/ConverterOptions",
                "title": "Converter_Options"
              },
              "overwrite_mode": {
                "$ref": "#/$defs/OverwriteMode",
                "default": "No Overwrite",
                "title": "Overwrite_Mode"
              }
            },
            "required": [
              "tiled_image_json_dump_url",
              "converter_options"
            ],
            "title": "ConvertParallelInitArgs",
            "type": "object"
          },
          "ConverterOptions": {
            "additionalProperties": false,
            "description": "Options for the OME-Zarr conversion process.",
            "properties": {
              "tiling_mode": {
                "$ref": "#/$defs/TilingMode",
                "default": "Auto",
                "description": "Tiling mode to use during conversion.\n- Auto: Automatically determine if Snap to Grid is possible,\notherwise use Snap to Corners.\n- Snap to Grid: Tile images to fit a regular grid. This is\nonly possible if image positions align to a grid (potentially with overlap).\n- Snap to Corners: Tile images to fit a grid defined by the corner\npositions.\n- Inplace: Write tiles in their original positions without tiling. This\nmay lead to artifacts if microscope stage positions are not precise.\n- No Tiling: Each field of view is written as a single OME-Zarr.",
                "title": "Tiling Mode"
              },
              "writer_mode": {
                "$ref": "#/$defs/WriterMode",
                "default": "By FOV",
                "description": "Mode for writing data during conversion.\n- By Tile: Write data one tile at a time. This consumes less memory,\nbut may be slower.\n- By Tile (Using Dask): Write tiles in parallel using Dask. This is\nusually faster than writing by tile sequentially, but may consume more\nmemory.\n- By FOV: Write data one field of view at a time. This may the best\ncompromise between speed and memory usage in most cases.\n- By FOV (Using Dask): Write fields of view in parallel using Dask.\nThis is usually faster than writing by FOV sequentially,\nbut may consume more memory.\n- In Memory: Load all data into memory before writing.",
                "title": "Writer Mode"
              },
              "alignment_correction": {
                "$ref": "#/$defs/AlignmentCorrections",
                "default": {
                  "align_xy": false,
                  "align_z": false,
                  "align_t": false
                },
                "description": "Alignment correction options.",
                "title": "Alignment Corrections"
              },
              "omezarr_options": {
                "$ref": "#/$defs/OmeZarrOptions",
                "default": {
                  "num_levels": 5,
                  "chunks": {
                    "c_chunk": 1,
                    "mode": "Same as FOV",
                    "t_chunk": 1,
                    "xy_scaling": "1",
                    "z_chunk": 10
                  },
                  "ngff_version": "0.4",
                  "table_backend": "anndata"
                },
                "description": "Options specific to OME-Zarr writing.",
                "title": "OME-Zarr Options"
              },
              "temp_json_options": {
                "$ref": "#/$defs/TempJsonOptions",
                "default": {
                  "temp_url": "{zarr_dir}/_tmp_json"
                },
                "description": "Options for temporary JSON storage.",
                "title": "Temporary JSON Options"
              }
            },
            "title": "ConverterOptions",
            "type": "object"
          },
          "FixedSizeChunking": {
            "description": "Chunking strategy with fixed chunk sizes.",
            "properties": {
              "mode": {
                "const": "Fixed Size",
                "default": "Fixed Size",
                "description": "mode: Fixed size chunking.",
                "title": "Mode",
                "type": "string"
              },
              "xy_chunk": {
                "default": 4096,
                "description": "xy_chunk: Chunk size for XY dimensions.",
                "minimum": 1,
                "title": "Chunk Size for XY",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "description": "z_chunk: Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "c_chunk: Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "t_chunk: Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FixedSizeChunking",
            "type": "object"
          },
          "FovBasedChunking": {
            "description": "Chunking strategy that matches the field of view.",
            "properties": {
              "mode": {
                "const": "Same as FOV",
                "default": "Same as FOV",
                "description": "Chunking based on FOV size.",
                "title": "Mode",
                "type": "string"
              },
              "xy_scaling": {
                "$ref": "#/$defs/Scalings",
                "default": "1",
                "description": "Scaling factor for XY chunk size. If set to 1, chunk size matches\nFOV size. If set to 0.5, chunk size is half the FOV size\n(smaller chunks, more files). If set to 2, chunk size is double the FOV\nsize (larger chunks, less files).",
                "title": "XY Scaling Factor"
              },
              "z_chunk": {
                "default": 10,
                "description": "Chunk size for Z dimension.",
                "minimum": 1,
                "title": "Chunk Size for Z",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "description": "Chunk size for C dimension.",
                "minimum": 1,
                "title": "Chunk Size for C",
                "type": "integer"
              },
              "t_chunk": {
                "default": 1,
                "description": "Chunk size for T dimension.",
                "minimum": 1,
                "title": "Chunk Size for T",
                "type": "integer"
              }
            },
            "title": "FovBasedChunking",
            "type": "object"
          },
          "OmeZarrOptions": {
            "additionalProperties": false,
            "description": "Options specific to OME-Zarr writing.",
            "properties": {
              "num_levels": {
                "default": 5,
                "minimum": 1,
                "title": "Num Levels",
                "type": "integer"
              },
              "chunks": {
                "default": {
                  "mode": "Same as FOV",
                  "xy_scaling": "1",
                  "z_chunk": 10,
                  "c_chunk": 1,
                  "t_chunk": 1
                },
                "discriminator": {
                  "mapping": {
                    "Fixed Size": "#/$defs/FixedSizeChunking",
                    "Same as FOV": "#/$defs/FovBasedChunking"
                  },
                  "propertyName": "mode"
                },
                "oneOf": [
                  {
                    "$ref": "#/$defs/FovBasedChunking"
                  },
                  {
                    "$ref": "#/$defs/FixedSizeChunking"
                  }
                ],
                "title": "Chunking Strategy"
              },
              "ngff_version": {
                "default": "0.4",
                "enum": [
                  "0.4",
                  "0.5"
                ],
                "title": "Ngff Version",
                "type": "string"
              },
              "table_backend": {
                "$ref": "#/$defs/BackendType",
                "default": "anndata",
                "title": "Table Backend"
              }
            },
            "title": "OmeZarrOptions",
            "type": "object"
          },
          "OverwriteMode": {
            "enum": [
              "No Overwrite",
              "Overwrite",
              "Extend"
            ],
            "title": "OverwriteMode",
            "type": "string",
            "description": "Missing description for OverwriteMode."
          },
          "Scalings": {
            "enum": [
              "0.25",
              "0.5",
              "1",
              "2",
              "4"
            ],
            "title": "Scalings",
            "type": "string",
            "description": "Missing description for Scalings."
          },
          "TempJsonOptions": {
            "description": "Options for temporary JSON storage during conversion.",
            "properties": {
              "temp_url": {
                "default": "{zarr_dir}/_tmp_json",
                "title": "Temp Url",
                "type": "string"
              }
            },
            "title": "TempJsonOptions",
            "type": "object"
          },
          "TilingMode": {
            "enum": [
              "Auto",
              "Snap to Grid",
              "Snap to Corners",
              "Inplace",
              "No Tiling"
            ],
            "title": "TilingMode",
            "type": "string",
            "description": "Missing description for TilingMode."
          },
          "WriterMode": {
            "enum": [
              "By Tile",
              "By FOV",
              "By FOV (Using Dask)",
              "By Tile (Using Dask)",
              "In Memory"
            ],
            "title": "WriterMode",
            "type": "string",
            "description": "Missing description for WriterMode."
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "URL to the OME-Zarr file."
          },
          "init_args": {
            "$ref": "#/$defs/ConvertParallelInitArgs",
            "title": "Init Args",
            "description": "Arguments for the compute task."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "ImageInPlateComputeTask"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-uzh-converters/stable"
    }
  ],
  "has_args_schemas": true,
  "args_schema_version": "pydantic_v2",
  "authors": "Fractal Core Team"
}
